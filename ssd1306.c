/*
 * ssd1306.c
 *
 * Created: 03-01-2018 17:33:26
 *  Author: osc
 *this modules purpose is to initiate and control the OLED display SSD1306 driver for the 128x64 OLED display 
 *The plus can be connected to PIN 24 and the GND to PIN 26 and sda goes to PIN 21 and the sck goes to PIN 20
 *http://microcontrolandos.blogspot.dk/2014/12/pic-ssd1306.html
 */ 
#include <string.h>

#include "driver/gpio.h"
#include "driver/i2c.h"
#include "esp_err.h"
#include "esp_log.h"
#include "freertos/task.h"

//#include "sdkconfig.h" // generated by "make menuconfig"

#include "ssd1306.h"
#include "data.h"





#define tag "SSD1306"
//#define portTICK_PERIOD_MS 1000

 esp_err_t i2c_example_master_init()
{
	int address=OLED_I2C_ADDRESS;
   
i2c_config_t conf;

conf.mode = I2C_MODE_MASTER;

conf.sda_io_num = SDA_GPIO1;  //14

conf.scl_io_num =SCL_GPIO1;   //2

conf.sda_pullup_en = GPIO_PULLUP_ENABLE;

conf.scl_pullup_en = GPIO_PULLUP_ENABLE;

conf.master.clk_speed = 1000000;
//conf.clk_flags = 0;

i2c_param_config(I2C_EXAMPLE_MASTER_NUM, &conf);

// install the driver

ESP_ERROR_CHECK(i2c_driver_install(I2C_EXAMPLE_MASTER_NUM, conf.mode,0,0,0));

printf("- i2c driver installed\r\n\r\n");

	i2c_cmd_handle_t cmd = i2c_cmd_link_create();

	i2c_master_start(cmd);

	i2c_master_write_byte(cmd, (address << 1) | I2C_MASTER_WRITE, true);

	i2c_master_stop(cmd);
	if(i2c_master_cmd_begin(I2C_EXAMPLE_MASTER_NUM, cmd, 100 / portTICK_RATE_MS) == ESP_OK) {
        // dev.i2c_addr=address;
		printf("-> found device with address 0x%02x\r\n", address);
	}
		i2c_cmd_link_delete(cmd);
return ESP_OK;
}
void SSD1306_DrawPixel(uint8_t x, uint8_t y, bool color)
{
  if ((x >= SSD1306_LCDWIDTH) || (y >= SSD1306_LCDHEIGHT))
    return;
  if (color)
    ssd1306_buffer[x + (uint16_t)(y / 8) * SSD1306_LCDWIDTH] |=  (1 << (y & 7));
  else
    ssd1306_buffer[x + (uint16_t)(y / 8) * SSD1306_LCDWIDTH] &=  ~(1 << (y & 7));
}

void  ssd1306_command(uint8_t c)
{
	uint8_t control = 0x00; // some use 0X00 other examples use 0X80. I tried both
esp_err_t espRc;

	i2c_cmd_handle_t cmd = i2c_cmd_link_create();
	i2c_master_start(cmd);
	i2c_master_write_byte(cmd, (OLED_I2C_ADDRESS << 1) | I2C_MASTER_WRITE, true);
	i2c_master_write_byte(cmd, control, true);

	i2c_master_write_byte(cmd, c, true);
	i2c_master_stop(cmd);

	espRc = i2c_master_cmd_begin(I2C_EXAMPLE_MASTER_NUM, cmd, 100/portTICK_PERIOD_MS);
	if (espRc == ESP_OK) {
	//	ESP_LOGI(tag, "OLED command successfully");
	} else {
		ESP_LOGE(tag, "OLED comand failed. code: 0x%.2X", espRc);
	}
	i2c_cmd_link_delete(cmd);
}
////////////////////////////////////////////
//
void  ssd1306_data(uint8_t c)
{
	esp_err_t espRc;

	i2c_cmd_handle_t cmd = i2c_cmd_link_create();

	i2c_master_start(cmd);
	i2c_master_write_byte(cmd, (OLED_I2C_ADDRESS << 1) | I2C_MASTER_WRITE, true);
	i2c_master_write_byte(cmd, 0x40, true);

	i2c_master_write_byte(cmd, c, true);
	i2c_master_stop(cmd);

	espRc = i2c_master_cmd_begin(I2C_EXAMPLE_MASTER_NUM, cmd, 100/portTICK_PERIOD_MS);
	if (espRc == ESP_OK) {
	//	ESP_LOGI(tag, "OLED command successfully");
	} else {
		ESP_LOGE(tag, "OLED comand failed. code: 0x%.2X", espRc);
	}
	i2c_cmd_link_delete(cmd);
}
///////////////////////////////////////////////////
// Used when doing Horizontal or Vertical Addressing
void setColAddress()
{
	ssd1306_command(SSD1306_COLUMNADDR); // 0x21 COMMAND
	ssd1306_command(0); // Column start address
	ssd1306_command(SSD1306_LCDWIDTH-1); // Column end address
}
/////////////////////////////////////////////////////
// Used when doing Horizontal or Vertical Addressing
void setPageAddress()
{
	ssd1306_command(SSD1306_PAGEADDR); // 0x22 COMMAND
	ssd1306_command(0); // Start Page address
	ssd1306_command((SSD1306_LCDHEIGHT/8)-1);// End Page address
}
///////////////////////////////////////////////////////////////////
// init according to SSD1306 data sheet and many places on the web
void  InitializeDisplay()
{
	 
	
	
	// Init sequence for 128x64 OLED module
	ssd1306_command(SSD1306_DISPLAYOFF);                    // 0xAE

	ssd1306_command(SSD1306_SETDISPLAYCLOCKDIV);            // 0xD5
	ssd1306_command(0x80);                 // the suggested ratio 0x80
	
	ssd1306_command(SSD1306_SETMULTIPLEX);                  // 0xA8
	ssd1306_command(0x3F);
	
	ssd1306_command(SSD1306_SETDISPLAYOFFSET);              // 0xD3
	ssd1306_command(0x0);                                   // no offset
	
	ssd1306_command(SSD1306_SETSTARTLINE);// | 0x0);        // line #0
	
	ssd1306_command(SSD1306_CHARGEPUMP);                    // 0x8D
	ssd1306_command(0x14);  // using internal VCC
	
	ssd1306_command(SSD1306_MEMORYMODE);                    // 0x20  ændret
	ssd1306_command(0x00);          // 0x00 horizontal addressing  ændret
	
	ssd1306_command(SSD1306_SEGREMAP | 0x1); // rotate screen 180
	
	ssd1306_command(SSD1306_COMSCANDEC); // rotate screen 180
	
	ssd1306_command(SSD1306_SETCOMPINS);                    // 0xDA
	ssd1306_command(0x12);
	
	ssd1306_command(SSD1306_SETCONTRAST);                   // 0x81
	ssd1306_command(0xCF);
	
	ssd1306_command(SSD1306_SETPRECHARGE);                  // 0xd9
	ssd1306_command(0xF1);
	
	ssd1306_command(SSD1306_SETVCOMDETECT);                 // 0xDB
	ssd1306_command(0x40);
	
	ssd1306_command(SSD1306_DISPLAYALLON_RESUME);           // 0xA4
	
	ssd1306_command(SSD1306_NORMALDISPLAY);                 // 0xA6
	
	ssd1306_command(SSD1306_DISPLAYON);                     //switch on OLED
	// set cursor to (0, 0)
  x_pos = 0;
  y_pos = 0;
  // set text size to 1
  text_size = 1;
}
//////////////////////////////
//
void SSD1306_StartScrollRight(uint8_t start, uint8_t stop)
{
  ssd1306_command(SSD1306_RIGHT_HORIZONTAL_SCROLL);
  ssd1306_command(0X00);
  ssd1306_command(start);
  ssd1306_command(0X00);
  ssd1306_command(stop);
  ssd1306_command(0X00);
  ssd1306_command(0XFF);
  ssd1306_command(SSD1306_ACTIVATE_SCROLL);
}

void SSD1306_StartScrollLeft(uint8_t start, uint8_t stop)
{
  ssd1306_command(SSD1306_LEFT_HORIZONTAL_SCROLL);
  ssd1306_command(0X00);
  ssd1306_command(start);
  ssd1306_command(0X00);
  ssd1306_command(stop);
  ssd1306_command(0X00);
  ssd1306_command(0XFF);
  ssd1306_command(SSD1306_ACTIVATE_SCROLL);
}

void SSD1306_StartScrollDiagRight(uint8_t start, uint8_t stop)
{
  ssd1306_command(SSD1306_SET_VERTICAL_SCROLL_AREA);
  ssd1306_command(0X00);
  ssd1306_command(SSD1306_LCDHEIGHT);
  ssd1306_command(SSD1306_VERTICAL_AND_RIGHT_HORIZONTAL_SCROLL);
  ssd1306_command(0X00);
  ssd1306_command(start);
  ssd1306_command(0X00);
  ssd1306_command(stop);
  ssd1306_command(0X01);
  ssd1306_command(SSD1306_ACTIVATE_SCROLL);
}

void SSD1306_StartScrollDiagLeft(uint8_t start, uint8_t stop)
{
  ssd1306_command(SSD1306_SET_VERTICAL_SCROLL_AREA);
  ssd1306_command(0X00);
  ssd1306_command(SSD1306_LCDHEIGHT);
  ssd1306_command(SSD1306_VERTICAL_AND_LEFT_HORIZONTAL_SCROLL);
  ssd1306_command(0X00);
  ssd1306_command(start);
  ssd1306_command(0X00);
  ssd1306_command(stop);
  ssd1306_command(0X01);
  ssd1306_command(SSD1306_ACTIVATE_SCROLL);
}

void SSD1306_StopScroll(void)
{
  ssd1306_command(SSD1306_DEACTIVATE_SCROLL);
}

void SSD1306_Dim(int dim)
{
  uint8_t contrast;
  if (dim)
    contrast = 0; // Dimmed display
  else {
    if (_vccstate == SSD1306_EXTERNALVCC)
      contrast = 0x9F;
    else
      contrast = 0xCF;
  }
  // the range of contrast to too small to be really useful
  // it is useful to dim the display
  ssd1306_command(SSD1306_SETCONTRAST);
  ssd1306_command(contrast);
}

void SSD1306_Display(void)
{
esp_err_t espRc;

	i2c_cmd_handle_t cmd = i2c_cmd_link_create();

  ssd1306_command(SSD1306_COLUMNADDR);
  ssd1306_command(0);   // Column start address (0 = reset)
  ssd1306_command(SSD1306_LCDWIDTH-1); // Column end address (127 = reset)

  ssd1306_command(SSD1306_PAGEADDR);
  ssd1306_command(0); // Page start address (0 = reset)
  #if SSD1306_LCDHEIGHT == 64
    ssd1306_command(7); // Page end address
  #endif
  #if SSD1306_LCDHEIGHT == 32
    ssd1306_command(3); // Page end address
  #endif
  #if SSD1306_LCDHEIGHT == 16
    ssd1306_command(1); // Page end address
  #endif
 for (uint16_t i = 0; i < (SSD1306_LCDWIDTH*SSD1306_LCDHEIGHT / 8); i++) {
      // send a bunch of data in one xmission
     uint8_t control = 0x00; // some use 0X00 other examples use 0X80. I tried both
	 
	i2c_master_start(cmd);
	i2c_master_write_byte(cmd, (OLED_I2C_ADDRESS << 1) | I2C_MASTER_WRITE, true);
	i2c_master_write_byte(cmd, control, true);
	 i2c_master_write_byte(cmd, 0X40, true);
      for (uint8_t x = 0; x < 16; x++) {
        i2c_master_write_byte(cmd, ssd1306_buffer[i], true);
        i++;
      }
      i--;
      i2c_master_stop(cmd);

	espRc = i2c_master_cmd_begin(I2C_EXAMPLE_MASTER_NUM, cmd, 100/portTICK_PERIOD_MS);
	if (espRc == ESP_OK) {
	//	ESP_LOGI(tag, "OLED command successfully");
	} else {
		ESP_LOGE(tag, "OLED comand failed. code: 0x%.2X", espRc);
	}

    }
	
	i2c_cmd_link_delete(cmd);
}


	
	


void bmp(bitmap_t b)
{
	int i,j;

	ssd1306_command(0x00);
	ssd1306_command(0x10);

	ssd1306_command(0xB0);

	for (j=0;j<8;j++)
	{
		for (i=0;i<128;i++)
		ssd1306_command( b[j][i] );
		ssd1306_command(0);
		ssd1306_command(0);
		ssd1306_command(0);
		ssd1306_command(0);
	}

}
void reset_display(void)
{
	displayOff();
	clear_display();

	
	displayOn();
}




//==========================================================//
// Turns display on.
void displayOn(void)
{
	ssd1306_command(0xaf);        //display on
}

//==========================================================//
// Turns display off.
void displayOff(void)
{
	ssd1306_command(0xae);		//display off
}

//==========================================================//
// Clears the display by sending 0 to all the screen map.
void clear_display(void)
{
	unsigned char i,k;
	for(k=0;k<8;k++)
	{
		setXY(k,0);
		{
			for(i=0;i<128;i++)     //clear all COL
			{
				SendChar(0);         //clear all COL
				//delay(10);
			}
		}
	}
}
void SSD1306_ClearDisplay(void)
{
  for (uint16_t i = 0; i < (SSD1306_LCDWIDTH*SSD1306_LCDHEIGHT / 8); i++)
    ssd1306_buffer[i] = 0;
}





//==========================================================//
void printBigTime(char *string)
{

	int Y=0;
	int lon = strlen(string);
	if(lon == 3) {
		Y = 0;
		} else if (lon == 2) {
		Y = 3;
		} else if (lon == 1) {
		Y = 6;
	}
	
	int X = 4;
	while(*string)
	{
		printBigNumber(*string, X, Y);
		
		Y+=3;
		X=4;
		setXY(X,Y);
		string++;
	}
}


//==========================================================//
// Prints a display big number (96 bytes) in coordinates X Y,
// being multiples of 8. This means we have 16 COLS (0-15)
// and 8 ROWS (0-7).
void printBigNumber(char string, int X, int Y)
{
	setXY(X,Y);
	int salto=0;
	for(int i=0;i<96;i++)
	{
		if(string == ' ') {
			SendChar(0);
		} else
		SendChar(bigNumbers[string-0x30][i]);
		
		if(salto == 23) {
			salto = 0;
			X++;
			setXY(X,Y);
			} else {
			salto++;
		}
	}
}

//==========================================================//
// Actually this sends a byte, not a char to draw in the display.
// Display's chars uses 8 byte font the small ones and 96 bytes
// for the big number font.
void SendChar(unsigned char data)
{
	esp_err_t espRc;

	i2c_cmd_handle_t cmd = i2c_cmd_link_create();

	i2c_master_start(cmd);
	i2c_master_write_byte(cmd, (OLED_I2C_ADDRESS << 1) | I2C_MASTER_WRITE, true);
	i2c_master_write_byte(cmd, 0x40, true);

	i2c_master_write_byte(cmd, data, true);
	i2c_master_stop(cmd);

	espRc = i2c_master_cmd_begin(I2C_EXAMPLE_MASTER_NUM, cmd, 10/portTICK_PERIOD_MS);
	if (espRc == ESP_OK) {
		//ESP_LOGI(tag, "OLED send char successfully");
	} else {
		ESP_LOGE(tag, "OLED comand failed. code: 0x%.2X", espRc);
	}
	i2c_cmd_link_delete(cmd);
}

//==========================================================//
// Prints a display char (not just a byte) in coordinates X Y,
// being multiples of 8. This means we have 16 COLS (0-15)
// and 8 ROWS (0-7).
void sendCharXY(unsigned char data, int X, int Y)
{
	setXY(X, Y);
	
	esp_err_t espRc;

	i2c_cmd_handle_t cmd = i2c_cmd_link_create();

	i2c_master_start(cmd);
	i2c_master_write_byte(cmd, (OLED_I2C_ADDRESS << 1) | I2C_MASTER_WRITE, true);
	i2c_master_write_byte(cmd, 0x40, true);
    for(int i=0;i<8;i++){
	i2c_master_write_byte(cmd, (uint8_t)myFont[data][i], true);
	}
	i2c_master_stop(cmd);

	espRc = i2c_master_cmd_begin(I2C_EXAMPLE_MASTER_NUM, cmd, 10/portTICK_PERIOD_MS);
	if (espRc == ESP_OK) {
	//	ESP_LOGI(tag, "OLED char x, y successfully");
	} else {
		ESP_LOGE(tag, "OLED comand failed. code: 0x%.2X", espRc);
	}
	i2c_cmd_link_delete(cmd);
}

//==========================================================//
// Set the cursor position in a 16 COL * 8 ROW map.
void setXY(unsigned char row,unsigned char col)
{
	ssd1306_command(0xb0+row);                //set page address
	ssd1306_command(0x00+(8*col&0x0f));       //set low col address
	ssd1306_command(0x10+((8*col>>4)&0x0f));  //set high col address
}


//==========================================================//
// Prints a string regardless the cursor position.
void sendStr(char *string)
{
	unsigned char i=0;
	
	while(*string)
     //for (k=0;k<strlen(string);k++)
	{
		for(i=0;i<8;i++)
		{
			SendChar(myFont[(uint8_t)*string][i]);
		}
		string++;
		
		
	}
}

//==========================================================//
// Prints a string in coordinates X Y, being multiples of 8.
// This means we have 16 COLS (0-15) and 8 ROWS (0-7). -0x20
void sendStrXY(char *string, int X, int Y)
{   
	setXY(X,Y);
	unsigned char i=0;
	while(*string)
	{    
		for(i=0;i<8;i++)
		{
			SendChar(myFont[(uint8_t)*string][i]);
		}
		string++;
	}
}
void SSD1306_DrawLine(int16_t x0, int16_t y0, int16_t x1, int16_t y1, bool color )
{
  int steep;
  int8_t ystep;
  uint8_t dx, dy;
  int16_t err;
  steep = abs(y1 - y0) > abs(x1 - x0);
  if (steep) {
    ssd1306_swap(x0, y0);
    ssd1306_swap(x1, y1);
  }
  if (x0 > x1) {
    ssd1306_swap(x0, x1);
    ssd1306_swap(y0, y1);
  }
  dx = x1 - x0;
  dy = abs(y1 - y0);

  err = dx / 2;
  if (y0 < y1)
    ystep = 1;
  else
    ystep = -1;

  for (; x0 <= x1; x0++) {
    if (steep) {
      if(color) SSD1306_DrawPixel(y0, x0,true);
      else      SSD1306_DrawPixel(y0, x0, false);
    }
    else {
      if(color) SSD1306_DrawPixel(x0, y0, true);
      else      SSD1306_DrawPixel(x0, y0, false);
    }
    err -= dy;
    if (err < 0) {
      y0  += ystep;
      err += dx;
    }
  }
}
void SSD1306_DrawCircle(int16_t x0, int16_t y0, int16_t r)
{
  int16_t f = 1 - r;
  int16_t ddF_x = 1;
  int16_t ddF_y = -2 * r;
  int16_t x = 0;
  int16_t y = r;

  SSD1306_DrawPixel(x0  , y0 + r,true);
  SSD1306_DrawPixel(x0  , y0 - r,true);
  SSD1306_DrawPixel(x0 + r, y0,true);
  SSD1306_DrawPixel(x0 - r, y0,true);

  while (x < y) {
    if (f >= 0) {
      y--;
      ddF_y += 2;
      f += ddF_y;
    }
    x++;
    ddF_x += 2;
    f += ddF_x;

    SSD1306_DrawPixel(x0 + x, y0 + y,true);
    SSD1306_DrawPixel(x0 - x, y0 + y,true);
    SSD1306_DrawPixel(x0 + x, y0 - y,true);
    SSD1306_DrawPixel(x0 - x, y0 - y,true);
    SSD1306_DrawPixel(x0 + y, y0 + x,true);
    SSD1306_DrawPixel(x0 - y, y0 + x,true);
    SSD1306_DrawPixel(x0 + y, y0 - x,true);
    SSD1306_DrawPixel(x0 - y, y0 - x,true);
  }

}

void SSD1306_DrawFastHLine(uint8_t x, uint8_t y, uint8_t w)
{
   SSD1306_DrawLine(x, y, x + w - 1, y, true);
}

void SSD1306_DrawFastVLine(uint8_t x, uint8_t y, uint8_t h)
{
  SSD1306_DrawLine(x, y, x, y + h - 1, true);
}

void SSD1306_FillRect(uint8_t x, uint8_t y, uint8_t w, uint8_t h)
{
  for (int16_t i = x; i < x + w; i++)
    SSD1306_DrawFastVLine(i, y, h);
}